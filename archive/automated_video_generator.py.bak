#!/usr/bin/env python3
"""
Modular Automated Video Generator

This script provides a modular workflow for automating video generation:
1. Capturing screenshots from StreamGank
2. Uploading these images to Cloudinary
3. Extracting and enriching movie data with ChatGPT
4. Generating a short script for the avatar
5. Creating a HeyGen video
6. Storing all information in the database

Each module can be run independently or as part of the complete workflow.

Usage:
    # Run the complete workflow
    python3 automated_video_generator.py --all
    
    # Run specific modules
    python3 automated_video_generator.py --capture-screenshots
    python3 automated_video_generator.py --upload-to-cloudinary --input screenshots/*.png
    python3 automated_video_generator.py --extract-data --num-movies 5
    python3 automated_video_generator.py --enrich-data --input movie_data.json
    python3 automated_video_generator.py --generate-script --input enriched_data.json
    python3 automated_video_generator.py --create-video --input script.txt
    python3 automated_video_generator.py --store-in-db --input metadata.json
"""

import os
import sys
import json
import time
import logging
import requests
import re
import datetime
import argparse
from pathlib import Path
from dotenv import load_dotenv
from playwright.sync_api import sync_playwright
import cloudinary
import cloudinary.uploader
import cloudinary.api
from supabase import create_client
import openai
from typing import Dict, List, Tuple, Optional, Any

# Logging configuration
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

# Cloudinary configuration
cloudinary.config(
    cloud_name="dodod8s0v",
    api_key="589374432754798",
    api_secret="iwOZJxSJ9SIE47BwVBsvQdYAfsg"
)

# Supabase configuration
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
supabase = create_client(SUPABASE_URL, SUPABASE_KEY)

# OpenAI configuration
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
openai.api_key = OPENAI_API_KEY

# HeyGen API Key
HEYGEN_API_KEY = os.getenv("HEYGEN_API_KEY")

# Creatomate API Key
CREATOMATE_API_KEY = os.getenv("CREATOMATE_API_KEY", "API_KEY")  # Default to placeholder if not set
CREATOMATE_TEMPLATE_ID = os.getenv("CREATOMATE_TEMPLATE_ID", "e11ad4cc-3fcb-4589-824b-b6ef018da1ba")

# Ensure output directories exist
screenshots_dir = Path("screenshots")
videos_dir = Path("videos")
clips_dir = Path("clips")
covers_dir = Path("covers")

# Create all directories
screenshots_dir.mkdir(exist_ok=True)
videos_dir.mkdir(exist_ok=True)
clips_dir.mkdir(exist_ok=True)
covers_dir.mkdir(exist_ok=True)

def capture_streamgank_screenshots(url="https://streamgank.com/?country=FR&genres=Horreur&platforms=netflix&type=Film"):
    """
    Capture screenshots of StreamGank in mobile format
    showing horror movie results on Netflix France
    """
    # Create a folder for screenshots if needed
    output_dir = "screenshots"
    os.makedirs(output_dir, exist_ok=True)
    
    # Timestamp for filenames
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    screenshot_paths = []
    
    with sync_playwright() as p:
        # Launch browser in mobile mode
        browser = p.chromium.launch(headless=False)
        
        # Define mobile context (iPhone 12 Pro Max dimensions)
        device = p.devices["iPhone 12 Pro Max"]
        context = browser.new_context(
            **device,
            locale='fr-FR',
            timezone_id='Europe/Paris',
        )
        
        # Open a new page
        page = context.new_page()
        
        # Access the StreamGank page
        logger.info(f"Accessing page: {url}")
        page.goto(url)
        
        # Wait for the page to load
        page.wait_for_selector("text=RESULTS", timeout=30000)
        logger.info("Page loaded successfully")
        
        # Handle cookie banner if present
        try:
            cookie_banner = page.wait_for_selector("text=We use cookies", timeout=5000)
            if cookie_banner:
                logger.info("Cookie banner detected")
                essential_button = page.wait_for_selector("button:has-text('Essential Only')", timeout=3000)
                if essential_button:
                    logger.info("Click on 'Essential Only' button")
                    essential_button.click()
                    time.sleep(2)
        except Exception as e:
            logger.info(f"No cookie banner or error: {str(e)}")
        
        time.sleep(5)
        
        # Screenshots for different pairs of movies
        captures = [
            {"name": "films_1_2", "scroll_position": 0},
            {"name": "films_3_4", "scroll_position": 800},
            {"name": "films_5_6", "scroll_position": 1600}
        ]
        
        for idx, capture in enumerate(captures):
            # Scroll to position
            page.evaluate(f"window.scrollTo(0, {capture['scroll_position']})")
            time.sleep(2)
            
            # Remove any remaining cookie elements
            page.evaluate("""() => {
                const elements = document.querySelectorAll('*');
                for (const el of elements) {
                    if (el.textContent && el.textContent.includes('cookies') && 
                        (el.style.position === 'fixed' || el.style.position === 'absolute' || 
                         getComputedStyle(el).position === 'fixed' || getComputedStyle(el).position === 'absolute')) {
                        el.style.display = 'none';
                    }
                }
            }""")
            
            # Take the screenshot
            screenshot_path = os.path.join(output_dir, f"{timestamp}_streamgank_{capture['name']}.png")
            page.screenshot(path=screenshot_path, full_page=False)
            logger.info(f"Screenshot {idx+1}/3 saved: {screenshot_path}")
            screenshot_paths.append(screenshot_path)
        
        # Close the browser
        browser.close()
        
    logger.info("All screenshots have been successfully taken!")
    return screenshot_paths

def upload_to_cloudinary(file_paths):
    """
    Upload images to Cloudinary and return the URLs
    """
    cloudinary_urls = []
    
    for file_path in file_paths:
        try:
            logger.info(f"Uploading {file_path} to Cloudinary...")
            response = cloudinary.uploader.upload(file_path, folder="streamgank_screenshots")
            url = response['secure_url']
            cloudinary_urls.append(url)
            logger.info(f"Image uploaded successfully: {url}")
        except Exception as e:
            logger.error(f"Error uploading to Cloudinary: {str(e)}")
    
    return cloudinary_urls

def extract_movie_data(num_movies=3):
    """
    Extract movie data from StreamGank
    Simulation - in a real case, this would use an API or web scraping
    Default changed to 3 movies to match Creatomate template
    """
    logger.info(f"Extracting data for {num_movies} movies...")
    
    # Simulated data - in a real case, this would be extracted from the website
    movie_data = [
        {
            "title": "Ã‡a",
            "platform": "Netflix",
            "year": "2017", 
            "imdb": "7.3/10",
            "description": "A group of children unite to fight an evil clown that terrorizes their town.",
            "thumbnail_url": "https://streamgank.com/images/ca.jpg",
            "genres": ["Horror", "Mystery & Thriller"],
            "clip_url": "https://example.com/clips/it.mp4"  # Mock clip URL
        },
        {
            "title": "The Witch",
            "platform": "Netflix",
            "year": "2015", 
            "imdb": "6.9/10",
            "description": "In 1630s New England, a family is torn apart by the forces of witchcraft and black magic.",
            "thumbnail_url": "https://streamgank.com/images/witch.jpg",
            "genres": ["Horror", "Mystery & Thriller"],
            "clip_url": "https://example.com/clips/witch.mp4"  # Mock clip URL
        },
        {
            "title": "L'Exorciste",
            "platform": "Netflix",
            "year": "1973", 
            "imdb": "8.0/10",
            "description": "A desperate mother seeks the help of two priests to save her daughter from demonic possession.",
            "thumbnail_url": "https://streamgank.com/images/exorcist.jpg",
            "genres": ["Horror", "Classics"],
            "clip_url": "https://res.cloudinary.com/dodod8s0v/video/upload/v1751356566/The_Haunting_of_Hill_House_jhztq4.mp4"  # Mock clip URL
        },
        {
            "title": "Conjuring",
            "platform": "Netflix",
            "year": "2013", 
            "imdb": "7.5/10",
            "description": "Paranormal investigators Ed and Lorraine Warren work to help a family terrorized by a dark presence in their farmhouse.",
            "thumbnail_url": "https://streamgank.com/images/conjuring.jpg",
            "genres": ["Horror", "Mystery & Thriller"],
            "clip_url": "https://example.com/clips/conjuring.mp4"  # Mock clip URL
        },
        {
            "title": "Hereditary",
            "platform": "Netflix",
            "year": "2018", 
            "imdb": "7.3/10",
            "description": "A grieving family is haunted by disturbing occurrences after their grandmother's death.",
            "thumbnail_url": "https://streamgank.com/images/hereditary.jpg",
            "genres": ["Horror", "Mystery & Thriller"],
            "clip_url": "https://example.com/clips/hereditary.mp4"  # Mock clip URL
        },
        {
            "title": "The Babadook",
            "platform": "Netflix",
            "year": "2014", 
            "imdb": "6.8/10",
            "description": "A widowed mother is battling with her son's fear of a monster lurking in the house, but soon discovers a sinister presence is nearby.",
            "thumbnail_url": "https://streamgank.com/images/babadook.jpg",
            "genres": ["Horror", "Mystery & Thriller"],
            "clip_url": "https://example.com/clips/babadook.mp4"  # Mock clip URL
        },
        {
            "title": "Get Out",
            "platform": "Netflix",
            "year": "2017", 
            "imdb": "7.7/10",
            "description": "A young African-American visits his white girlfriend's parents for the weekend, where his simmering uneasiness about their reception of him eventually reaches a boiling point.",
            "thumbnail_url": "https://streamgank.com/images/getout.jpg",
            "genres": ["Horror", "Mystery & Thriller"],
            "clip_url": "https://example.com/clips/getout.mp4"  # Mock clip URL
        }
    ]
    
    logger.info(f"Data extracted for {len(movie_data)} movies")
    return movie_data[:num_movies]

def enrich_movie_data(movie_data):
    """
    Enrich movie data with ChatGPT for more engaging descriptions
    """
    logger.info("Enriching movie data with ChatGPT...")
    
    for movie in movie_data:
        try:
            # Creating prompt for ChatGPT
            prompt = f"""
            GÃ©nÃ¨re une description courte et engageante pour le film d'horreur "{movie['title']}" pour une vidÃ©o TikTok/YouTube.
            
            Informations:
            - Titre: {movie['title']}
            - Score IMDb: {movie['imdb']}
            - AnnÃ©e: {movie['year']}
            - Genres: {', '.join(movie['genres'])}
            
            CritÃ¨res:
            1. 1-2 phrases maximum (TRÃˆS COURT)
            2. Ton dÃ©contractÃ© qui accroche un public jeune
            3. Mentionne le score IMDb et l'annÃ©e
            4. Ne rÃ©vÃ¨le pas trop l'intrigue
            
            RÃ©ponds UNIQUEMENT avec le texte enrichi, sans prÃ©ambule.
            """
            
            response = openai.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are a horror film expert who creates short and engaging content for social media."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=100  # Limited to enforce brevity
            )
            
            enriched_description = response.choices[0].message.content.strip()
            movie["enriched_description"] = enriched_description
            logger.info(f"Enriched description generated for {movie['title']}")
            
        except Exception as e:
            logger.error(f"Error during enrichment for {movie['title']}: {str(e)}")
            movie["enriched_description"] = f"This horror movie from {movie['year']} with an IMDb score of {movie['imdb']} will chill your blood!"
    
    return movie_data

def generate_script(enriched_movies, cloudinary_urls):
    """
    Generate a script for the avatar video
    Updated to create separate scripts for intro+movie1, movie2, and movie3
    """
    logger.info("Generating scripts for avatar videos (intro+movie1, movie2, movie3)...")
    
    # Create separate scripts for intro+movie1, movie2, and movie3
    script_intro_movie1 = f"""Hello horror movie fans! Here are the top horror films to watch on Netflix France right now!

First, let's check out {enriched_movies[0]['title']} from {enriched_movies[0]['year']} with an IMDb score of {enriched_movies[0]['imdb']}. {enriched_movies[0]['enriched_description']}"""
    
    script_movie2 = f"""Next, we have {enriched_movies[1]['title']} from {enriched_movies[1]['year']}. {enriched_movies[1]['enriched_description']} This one got an IMDb rating of {enriched_movies[1]['imdb']}."""
    
    script_movie3 = f"""And finally, {enriched_movies[2]['title']} from {enriched_movies[2]['year']}. {enriched_movies[2]['enriched_description']} It earned an IMDb score of {enriched_movies[2]['imdb']}. Which one will you be watching first? Let us know in the comments below!"""
    
    # Conclusion
    # Save to separate files
    scripts = {
        "intro_movie1": {
            "text": script_intro_movie1,
            "path": "videos/intro_movie1_script.txt"
        },
        "movie2": {
            "text": script_movie2,
            "path": "videos/movie2_script.txt"
        },
        "movie3": {
            "text": script_movie3,
            "path": "videos/movie3_script.txt"
        }
    }
    
    # Write all scripts to files
    for key, script_data in scripts.items():
        with open(script_data["path"], "w") as f:
            f.write(script_data["text"])
    
    logger.info(f"Scripts generated and saved to videos directory")
    
    # Return combined script for compatibility with existing functions
    combined_script = script_intro_movie1 + "\n\n" + script_movie2 + "\n\n" + script_movie3
    combined_path = "videos/combined_script.txt"
    with open(combined_path, "w") as f:
        f.write(combined_script)
    
    return combined_script, combined_path, scripts

def download_heygen_video(video_id: str) -> str:
    """
    Download a HeyGen video by its ID and upload to Cloudinary
    
    Args:
        video_id: HeyGen video ID
        
    Returns:
        Cloudinary URL for the uploaded HeyGen video
    """
    logger.info(f"Downloading HeyGen video with ID: {video_id}")
    
    api_key = os.getenv('HEYGEN_API_KEY')
    if not api_key:
        logger.error("HEYGEN_API_KEY not found in environment variables")
        return ""
    
    # First try to directly access the video file using different URL patterns
    video_urls_to_try = [
        f"https://assets.heygen.ai/video/{video_id}.mp4",
        f"https://cdn.heygen.com/video/{video_id}.mp4",
        f"https://media.heygen.com/video/{video_id}.mp4",
    ]
    
    headers = {
        "accept": "application/json",
        "X-Api-Key": api_key
    }
    
    # Try to download using direct URLs first
    for video_url in video_urls_to_try:
        try:
            logger.info(f"Trying to download HeyGen video from: {video_url}")
            video_response = requests.get(video_url, stream=True, timeout=5)
            if video_response.status_code == 200 and video_response.headers.get('Content-Type', '').startswith('video/'):
                # Found a working URL - download and upload to Cloudinary
                return download_and_upload_to_cloudinary(video_url, video_id)
        except Exception as e:
            logger.warning(f"Failed to download from {video_url}: {str(e)}")
            continue
    
    # If direct URLs didn't work, try using the API to get the video
    try:
        # Try v1 endpoint
        status_url = f"https://api.heygen.com/v1/video/status?video_id={video_id}"
        logger.info(f"Trying v1 status endpoint: {status_url}")
        response = requests.get(status_url, headers=headers)
        
        if response.status_code != 200:
            # Try v2 endpoint
            status_url = f"https://api.heygen.com/v2/video/status?video_id={video_id}"
            logger.info(f"Trying v2 status endpoint: {status_url}")
            response = requests.get(status_url, headers=headers)
        
        if response.status_code == 200:
            status_data = response.json()
            
            # Try to find video_url in different places in the response
            video_url = None
            if 'data' in status_data and 'video_url' in status_data['data']:
                video_url = status_data['data']['video_url']
            elif 'video_url' in status_data:
                video_url = status_data['video_url']
            
            if video_url:
                logger.info(f"Found video URL via API: {video_url}")
                return download_and_upload_to_cloudinary(video_url, video_id)
    except Exception as e:
        logger.error(f"Error getting HeyGen video status: {str(e)}")
    
    # If all attempts failed, try the video player URL as last resort
    try:
        player_url = f"https://app.heygen.com/video_share/watch?id={video_id}"
        logger.info(f"Trying to scrape video URL from player page: {player_url}")
        
        # Here we would need to implement web scraping to extract the video URL from the player page
        # This is complex and requires browser automation, so we'll skip for now
        
    except Exception as e:
        logger.error(f"Error scraping player page: {str(e)}")
    
    logger.error(f"All attempts to download HeyGen video {video_id} failed")
    return ""


def get_video_duration(video_url: str) -> float:
    """
    Get the duration of a video from Cloudinary or other source
    
    Args:
        video_url: URL of the video
        
    Returns:
        Duration of the video in seconds (or default value if couldn't determine)
    """
    try:
        # If it's a Cloudinary URL, we can parse the public ID and use Cloudinary API
        if "cloudinary" in video_url and "/video/upload/" in video_url:
            # Improved extraction of public ID from Cloudinary URL
            # Example URL: https://res.cloudinary.com/dodod8s0v/video/upload/v1752582467/intro_movie1_kegi9p.mp4
            # or: https://res.cloudinary.com/dodod8s0v/video/upload/intro_movie1_kegi9p.mp4
            parts = video_url.split("/upload/")
            if len(parts) == 2:
                # Extract everything after /upload/ and before file extension if present
                path_after_upload = parts[1]
                
                # Handle versioning formats (vXXXXXXXXX/) if present
                if path_after_upload.startswith("v"):
                    version_match = re.match(r"v\d+/(.+)$", path_after_upload)
                    if version_match:
                        public_id = version_match.group(1).rsplit(".", 1)[0]  # Remove file extension
                    else:
                        public_id = path_after_upload.rsplit(".", 1)[0]  # Remove file extension
                else:
                    public_id = path_after_upload.rsplit(".", 1)[0]  # Remove file extension
                
                logger.info(f"Extracted public_id from URL: {public_id}")
                
                try:
                    # Get resource details from Cloudinary
                    result = cloudinary.api.resource(public_id, resource_type="video")
                    if result and "duration" in result:
                        duration = float(result["duration"])
                        logger.info(f"Retrieved duration for video {public_id}: {duration} seconds")
                        return duration
                except Exception as e:
                    logger.error(f"Cloudinary API error for {public_id}: {str(e)}")
            
        # Since accurately determining video duration is critical for preventing overlap,
        # use these known durations for specific videos we're working with
        video_durations = {
            "intro_movie1_kegi9p": 15.5,  # Duration in seconds for intro+movie1
            "movie2_knfyfm": 14.2,      # Duration in seconds for movie2
            "movie3_m5h4ta": 13.8       # Duration in seconds for movie3
        }
        
        # Check if we can match the filename in our known durations
        for video_id, duration in video_durations.items():
            if video_id in video_url:
                logger.info(f"Using predefined duration for {video_id}: {duration} seconds")
                return duration
        
        # If still no match, use a longer default to be safe (prevents overlap)
        default_duration = 20.0
        logger.warning(f"Couldn't determine video duration for {video_url}, using safe default: {default_duration}s")
        return default_duration
        
    except Exception as e:
        logger.error(f"Error getting video duration: {str(e)}")
        return 20.0  # Longer default duration if we can't determine it to prevent overlap

def download_and_upload_to_cloudinary(video_url: str, video_id: str):
    """
    Helper function to download a video from a URL and upload it to Cloudinary
    
    Args:
        video_url: URL of the video to download
        video_id: HeyGen video ID (for logging)
        
    Returns:
        Cloudinary URL for the uploaded video
    """
    try:
        # Download the video to a temporary file
        with tempfile.NamedTemporaryFile(delete=False, suffix='.mp4') as temp_file:
            video_response = requests.get(video_url, stream=True)
            video_response.raise_for_status()
            
            for chunk in video_response.iter_content(chunk_size=8192):
                temp_file.write(chunk)
            
            temp_filename = temp_file.name
        
        # Upload to Cloudinary
        logger.info(f"Uploading HeyGen video {video_id} to Cloudinary")
        upload_result = cloudinary.uploader.upload(
            temp_filename,
            resource_type="video",
            folder="heygen_videos"
        )
        
        # Remove the temporary file
        os.unlink(temp_filename)
        
        if 'secure_url' in upload_result:
            logger.info(f"Successfully uploaded HeyGen video {video_id} to Cloudinary")
            return upload_result['secure_url']
        else:
            logger.error("Failed to upload HeyGen video to Cloudinary")
            return ""
    except Exception as e:
        logger.error(f"Error downloading or uploading video: {str(e)}")
        return ""

def create_heygen_video(script_data):
    """
    Create videos with the HeyGen API
    Updated to handle multiple scripts (intro+movie1, movie2, movie3)
    
    Args:
        script_data: Dictionary containing scripts or a single script string
    
    Returns:
        Dictionary of video IDs or a single video ID string
    """
    logger.info("Preparing requests to HeyGen API...")
    
    # If script_data is a string (direct script text), wrap it in a standard format
    if isinstance(script_data, str):
        script_data = {
            "single_video": {
                "text": script_data,
                "path": "direct_input"
            }
        }
    
    # Handle different dictionary formats
    if isinstance(script_data, dict):
        videos = {}
        # Process each script in the dictionary
        for key, script_info in script_data.items():
            logger.info(f"Creating video for {key}...")
            
            # Extract the script text based on structure
            if isinstance(script_info, dict) and "text" in script_info:
                script_text = script_info["text"]
            else:
                script_text = str(script_info)  # Convert to string as fallback
            
            # Preparing payload for HeyGen API - updated to official format
            payload = {
                "video_inputs": [
                    {
                        "character": {
                            "type": "avatar",
                            "avatar_id": "Ann_Casual_Sitting_public",
                            "avatar_style": "normal"
                        },
                        "voice": {
                            "type": "text",
                            "input_text": script_text,
                            "voice_id": "ef74816547734c36ab44fd4f4d7434c3",
                            "speed": 1.0
                        },
                        "background": {
                            "type": "color",
                            "value": "#00FF00"
                        }
                    }
                ],
                "dimension": {
                    "width": 1280,
                    "height": 720
                }
            }
            
            # Make the API call and store the video ID
            video_id = send_heygen_request(payload)
            videos[key] = video_id
        
        return videos
    else:
        # Handle as list or other iterable - legacy support
        logger.warning("Received script_data in unexpected format. Attempting to use first item.")
        try:
            script = script_data[0] if hasattr(script_data, "__getitem__") else str(script_data)
            
            # Preparing payload for single video - updated to official format
            payload = {
                "video_inputs": [
                    {
                        "character": {
                            "type": "avatar",
                            "avatar_id": "Ann_Casual_Sitting_public",
                            "avatar_style": "normal"
                        },
                        "voice": {
                            "type": "text",
                            "input_text": script,
                            "voice_id": "ef74816547734c36ab44fd4f4d7434c3",
                            "speed": 1.0
                        },
                        "background": {
                            "type": "color",
                            "value": "#00FF00"
                        }
                    }
                ],
                "dimension": {
                    "width": 1280,
                    "height": 720
                }
            }
            
            video_id = send_heygen_request(payload)
            return {"single_video": video_id}
        except Exception as e:
            logger.error(f"Error processing script data: {e}")
            return None
    
def send_heygen_request(payload):
    """
    Helper function to send requests to HeyGen API
    
    Args:
        payload: API request payload
    
    Returns:
        Video ID if successful, None otherwise
    """
    logger.info("Sending request to HeyGen API...")
    
    # Load API key from environment
    heygen_api_key = os.getenv("HEYGEN_API_KEY")
    if not heygen_api_key:
        logger.error("HEYGEN_API_KEY not found in environment variables")
        return None
    
    # Set up headers with X-Api-Key as per official documentation
    headers = {
        "X-Api-Key": heygen_api_key,
        "Content-Type": "application/json"
    }
    
    try:
        # Use the official HeyGen API endpoint as per documentation
        response = requests.post(
            "https://api.heygen.com/v2/video/generate",
            headers=headers,
            json=payload
        )
        
        # Log the complete response for debugging
        logger.info(f"Raw response: {response.text}")
        
        if response.status_code in [200, 201]:
            data = response.json()
            if "data" in data and "video_id" in data["data"]:
                video_id = data["data"]["video_id"]
                logger.info(f"Video generation in progress. ID: {video_id}")
                return video_id
            else:
                logger.error(f"Unexpected response format: {data}")
                return None
        else:
            logger.error(f"Error creating video: {response.status_code}")
            logger.error(f"Details: {response.text}")
            return None
    except Exception as e:
        logger.error(f"Exception during video creation: {str(e)}")
        return None

def create_creatomate_video(
    movie_data: List[Dict[str, Any]] = None,
    heygen_video_ids: Dict[str, str] = None,
    cloudinary_urls: Dict[str, str] = None
) -> str:
    """
    Create a video with Creatomate using provided movie data and HeyGen videos
    
    Args:
        movie_data: List of movie data dictionaries
        heygen_video_ids: Dictionary of HeyGen video IDs
        cloudinary_urls: Dictionary of Cloudinary URLs
        
    Returns:
        Creatomate render ID
    """
    logger.info("Creating final video with Creatomate...")
    
    # Check if movie_data is available, if not, try to load from enriched_data.json
    if not movie_data:
        try:
            logger.info("No movie data provided, attempting to load from enriched_data.json...")
            with open('videos/enriched_data.json', 'r') as f:
                movie_data = json.load(f)
            logger.info(f"Successfully loaded movie data: {len(movie_data)} movies")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logger.error(f"Failed to load movie data: {e}")
            # Create placeholder movie data if loading fails
            movie_data = [
                {"title": "Movie 1", "thumbnail_url": "https://placeholder.com/movie1.jpg", "clip_url": ""},
                {"title": "Movie 2", "thumbnail_url": "https://placeholder.com/movie2.jpg", "clip_url": ""},
                {"title": "Movie 3", "thumbnail_url": "https://placeholder.com/movie3.jpg", "clip_url": ""}
            ]
    
    # In a real implementation, we would first check that HeyGen videos are complete
    # and get their download URLs. For now we'll use placeholders.
    
    # Use publicly accessible video placeholders when actual HeyGen videos aren't available
    PUBLIC_VIDEO_PLACEHOLDER = "https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4"
    
    # Construct URLs for HeyGen videos, using public placeholders when needed
    heygen_video_urls = {}
    
    # For each video position, check if we have a valid HeyGen video ID
    # If yes, download and upload to Cloudinary, otherwise use a public placeholder video
    for key in ['intro_movie1', 'movie2', 'movie3']:
        video_id = heygen_videos.get(key, '')
        if video_id and video_id != 'placeholder':
            logger.info(f"Processing HeyGen video for {key} with ID: {video_id}")
            
            # Download HeyGen video and upload to Cloudinary
            cloudinary_url = download_heygen_video(video_id)
            
            if cloudinary_url:
                # Successfully downloaded and uploaded to Cloudinary
                heygen_video_urls[key] = cloudinary_url
                logger.info(f"Using Cloudinary URL for HeyGen video {key}: {cloudinary_url}")
            else:
                # Failed to download/upload, use a publicly accessible placeholder
                heygen_video_urls[key] = "https://res.cloudinary.com/dodod8s0v/video/upload/v1751353401/the_last_of_us_zljllt.mp4"
                logger.warning(f"Failed to download HeyGen video {video_id}, using placeholder instead")
        else:
            # Use a publicly accessible placeholder video
            heygen_video_urls[key] = PUBLIC_VIDEO_PLACEHOLDER
            logger.info(f"Using public placeholder video for {key}")
            
        # Cache the HeyGen video URLs for future use
        # This avoids re-downloading the same video multiple times
        # TODO: Implement caching mechanism if needed
    
    
    # Use the specific Cloudinary URLs for movie covers provided by the user
    movie_covers = [
        "https://res.cloudinary.com/dodod8s0v/image/upload/v1751373016/1_TheLastOfUs_w5l6o7.png",
        "https://res.cloudinary.com/dodod8s0v/image/upload/v1751373201/2_Strangerthings_bidszb.png",
        "https://res.cloudinary.com/dodod8s0v/image/upload/v1751373245/3_Thehaunting_grxuop.png"
    ]
    
    # Function to validate and fix image URLs for Creatomate
    def validate_image_url(url):
        # If URL contains 'streamgank.com/images', replace with a direct image URL
        # as these URLs appear to be web pages, not direct image files
        if url and ('streamgank.com/images' in url or 'placeholder.com' in url):
            logger.info(f"Replacing non-direct image URL: {url}")
            return "https://placehold.co/600x400/png"  # Use a guaranteed direct image URL
        return url
        
    # Handle different movie_data structures to get thumbnail URLs
    if isinstance(movie_data, list):
        # Handle list of dictionaries
        for i in range(min(len(movie_data), 3)):
            if isinstance(movie_data[i], dict):
                url = movie_data[i].get("thumbnail_url", movie_covers[i])
                movie_covers[i] = validate_image_url(url)
    elif isinstance(movie_data, dict):
        # Handle dictionary with keys
        url1 = movie_data.get("thumbnail_url_1", movie_data.get("thumbnail_url", movie_covers[0]))
        url2 = movie_data.get("thumbnail_url_2", movie_covers[1])
        url3 = movie_data.get("thumbnail_url_3", movie_covers[2])
        movie_covers[0] = validate_image_url(url1)
        movie_covers[1] = validate_image_url(url2)
        movie_covers[2] = validate_image_url(url3)
    
    # Construct modifications for Creatomate template
    # Use thumbnail_url for movie covers and clip_url for movie clips
    # Use the specific Cloudinary URLs for movie clips provided by the user
    clip_url1 = "https://res.cloudinary.com/dodod8s0v/video/upload/v1751353401/the_last_of_us_zljllt.mp4"
    clip_url2 = "https://res.cloudinary.com/dodod8s0v/video/upload/v1751355284/Stranger_Things_uyxt3a.mp4"
    clip_url3 = "https://res.cloudinary.com/dodod8s0v/video/upload/v1751356566/The_Haunting_of_Hill_House_jhztq4.mp4"
    
    # Log the URLs being used
    logger.info(f"Using movie clip URLs: {clip_url1}, {clip_url2}, {clip_url3}")
    
    # Skip loading from movie_data since we're using the provided Cloudinary URLs
        
    # Use the Cloudinary URLs directly in the modifications
    cloudinary_movie_covers = [
        "https://res.cloudinary.com/dodod8s0v/image/upload/v1751373016/1_TheLastOfUs_w5l6o7.png",
        "https://res.cloudinary.com/dodod8s0v/image/upload/v1751373201/2_Strangerthings_bidszb.png",
        "https://res.cloudinary.com/dodod8s0v/image/upload/v1751373245/3_Thehaunting_grxuop.png"
    ]
    
    # Log the cover images being used
    logger.info(f"Using movie cover images: {cloudinary_movie_covers}")
    
    # Debug info - log Creatomate element details to help diagnose the issue
    logger.info("Debug: Creatomate template elements")
    
    # Verify movie clips are valid and accessible
    for i, url in enumerate([clip_url1, clip_url2, clip_url3]):
        logger.info(f"Verifying movie clip {i+1}: {url}")
        try:
            response = requests.head(url, timeout=5)
            if response.status_code == 200:
                logger.info(f"Movie clip {i+1} is accessible")
            else:
                logger.warning(f"Movie clip {i+1} might not be accessible: HTTP {response.status_code}")
        except Exception as e:
            logger.warning(f"Could not verify movie clip {i+1}: {str(e)}")
    
    # Verify cover images are valid and accessible
    for i, url in enumerate(cloudinary_movie_covers):
        logger.info(f"Verifying cover image {i+1}: {url}")
        try:
            response = requests.head(url, timeout=5)
            if response.status_code == 200:
                logger.info(f"Cover image {i+1} is accessible")
            else:
                logger.warning(f"Cover image {i+1} might not be accessible: HTTP {response.status_code}")
        except Exception as e:
            logger.warning(f"Could not verify cover image {i+1}: {str(e)}")
            
    # Log the template structure we're using
    logger.info("Template elements:")
    logger.info(f"  - heygenIntro+movie1: video element for intro+movie1 HeyGen")
    logger.info(f"  - movie1_cover: image element for movie1 cover")
    logger.info(f"  - movie1_clip: video element for movie1 clip")
    logger.info(f"  - heygenMovie2: video element for movie2 HeyGen")
    logger.info(f"  - movie2_cover: image element for movie2 cover")
    logger.info(f"  - movie2_clip: video element for movie2 clip")
    logger.info(f"  - heygenMovie3: video element for movie3 HeyGen")
    logger.info(f"  - movie3_cover: image element for movie3 cover")
    logger.info(f"  - movie3_clip: video element for movie3 clip")
    
    # Re module is now imported at the top of the file
    
    # Set fixed clip duration and zero gap between sections
    clip_duration = 8     # Duration for movie clips
    section_gap = 0.01    # Almost zero gap for continuous playback
    
    # Define the HeyGen video URLs
    heygen_videos = {
        "intro_movie1": "https://res.cloudinary.com/dodod8s0v/video/upload/v1752582467/intro_movie1_kegi9p.mp4",
        "movie2": "https://res.cloudinary.com/dodod8s0v/video/upload/v1752582475/movie2_knfyfm.mp4",
        "movie3": "https://res.cloudinary.com/dodod8s0v/video/upload/v1752582467/movie3_m5h4ta.mp4"
    }
    
    # Get durations of the HeyGen videos    # Define the HeyGen video URLs
    heygen_videos = {
        "intro_movie1": heygen_cloudinary_urls.get("intro_movie1", DEFAULT_VIDEO_URL),
        "movie2": heygen_cloudinary_urls.get("movie2", DEFAULT_VIDEO_URL),
        "movie3": heygen_cloudinary_urls.get("movie3", DEFAULT_VIDEO_URL)
    }
    
    # Log the heygen video URLs for debugging
    logger.info(f"Using HeyGen video URLs:")
    for key, url in heygen_videos.items():
        logger.info(f"  - {key}: {url}")
    
    # Calculate precise timing to avoid gaps and ensure continuous content
    
    # Section 1 timing
    section1_start = 0
{{ ... }}
                
                # Determine the type of data we have
                if isinstance(file_data, list):
                    # Assume this is movie_data list
                    logger.info(f"Loaded input file as movie_data list with {len(file_data)} items")
           # Get HeyGen video IDs from input or use placeholders
    if heygen_video_ids and len(heygen_video_ids) > 0:
        logger.info(f"Using provided HeyGen video IDs: {heygen_video_ids}")
    else:
        # Use default HeyGen video IDs if none provided
        heygen_video_ids = {
            "intro_movie1": "placeholder_intro_movie1",
            "movie2": "placeholder_movie2",
            "movie3": "placeholder_movie3"
        }
        logger.info(f"No HeyGen video IDs provided, using placeholders: {heygen_video_ids}")_data, dict):
                    # Extract data from metadata dictionary
                    logger.info(f"Loaded input file as metadata dictionary")
                    heygen_video_ids = file_data.get('heygen_videos', {}) or file_data.get('video_id', {})
                    movie_data = file_data.get('enriched_movies', []) or file_data.get('movie_data', [])
                    cloudinary_urls = file_data.get('cloudinary_urls', {}) or {}
        else:
            # Use data from previous steps
            heygen_video_ids = results.get('heygen_videos', {}) or results.get('video_id', {})
            movie_data = results.get('enriched_movies', []) or results.get('movie_data', [])
            cloudinary_urls = results.get('cloudinary_urls', {}) or {}
        
        # Log what data we have
        logger.info(f"Creating Creatomate video with: {len(movie_data)} movies, "
                   f"{len(heygen_videos)} HeyGen videos, {len(cloudinary_urls)}        # Call the main function to create the Creatomate video
        results['creatomate_id'] = create_creatomate_video(movie_data=movie_data, heygen_video_ids=heygen_video_ids, cloudinary_urls=cloudinary_urls)
        if args.output:
            with open(args.output, 'w') as f:
                json.dump({'creatomate_id': results['creatomate_id']}, f, indent=2)
    
    if args.store_in_db:
{{ ... }}
            with open(args.input, 'r') as f:
                metadata = json.load(f)
                # Extract required data from metadata
                movie_data = metadata.get('enriched_movies', [])
                cloudinary_urls = metadata.get('cloudinary_urls', [])
                video_id = metadata.get('video_id', None)
                script_path = metadata.get('script_path', None)
        else:
            # Use data from previous steps
            movie_data = results.get('enriched_movies', [])
            cloudinary_urls = results.get('cloudinary_urls', [])
            video_id = results.get('video_id', None)
            script_path = results.get('script_path', None)
            
            if not (movie_data and cloudinary_urls and video_id and script_path):
                print("Error: Missing required data for database storage.")
                exit(1)
        
        group_id = store_in_database(movie_data, cloudinary_urls, video_id, script_path)
        results['group_id'] = group_id
        if args.output:
            with open(args.output, 'w') as f:
                json.dump({'group_id': group_id}, f, indent=2)
